EVENT HANDLING AND SIGNALING IN LINUX

The Folder Contains the folowing files :
task1.c
task2a.c
task2b.c
task2c.c
task3a.c
task3b.c

Steps to execute:
=================

1) make all -this will generate all the object files to be executed 

2) make clean - this will delete all the object files .
 Note : Please Change the events according to the mouse event on your system

Execution of each Task
**********************
1) sudo ./task1 -- double click the right mouse button & the impricise calculation will be output
2) sudo trace-cmd record -e sched_switch -e signal taskset 0x01 ./task2a 
	kernelshark trace.dat -- Use necessary filters & plot function to observe the output as shown in report  
3) sudo trace-cmd record -e sched_switch -e signal taskset 0x01 ./task2b 
	kernelshark trace.dat -- Use necessary filters & plot function to observe the output as shown in report
4) sudo trace-cmd record -e sched_switch -e signal taskset 0x01 ./task2c --move the mouse to generate signal to main thread
	kernelshark trace.dat -- Use necessary filters & plot function to observe the output as shown in report
5) sudo ./task3a -- make mouse movements to invoke the signal 
6) sudo ./task3b -- make mouse movements to invoke the signal 


===========================================================================================================================
Task1.c
=======
Expalination
************
This part of the assignment makes use of one threads to detect mouse event.
This thread is used to generate the signal by detecting double right click from the 
mouse and main thread is used to do imprecise computation. The results
of the computation is displayed as soon as double click event is generated.
For double click event, the thread waits for 0.5s for second click
otherwise it is detected as a single click. 


Task2a.c
=======
Expalination
************
This part of assignment uses 2 threads. A high priority thread & low priority thread. The high priority
will be scheduled& is running. The low priority thread is waiting to be scheduled & is runnable. When
high priority thread invokes the low priority thread with a signal the higher priority thread will finish
execution & then lower priority thread will be scheduled at which time the control enters handler. Its
then the lower priority thread will be executed.

Task2b.c
=======
Expalination
************
This part of the assignment makes use of one threads to which waits for semaphore.
The main thread generates a SIGUSR1 signal after 3 seconds.The thread which waits for semaphore is registered with SIGUSR1
When the signal is delivered to the waiting semaphore, the semaphore is released to execute remaining part of code.



Task2c.c
========
Expalination
************
This part of assignment uses nanosleep to show that when a signal interrupts the nanosleep the control executes handler function , returns to execute remaining portion of nanosleep . When the handler function is executed the remaining time to sleep is printed , returns to main function to continue sleeping for remaining portion of time . This is stored in vairable called "a".


Task3a.c
========
Expalination
************
This part of assignment creates 10 threads & each thread is registered to a same signal. Each of them is served by single handler .
Each time a signal is generated by mouse the arbitrary thread receives the signal & jumps to its respective handler & finally joins the thread.  Please refer the image for the output.(task3a.png)

Task3b.c
========
Expalination
************
This part of assignment creates 10 threads & each thread is registered to a same signal. Each of them is served by single handler .
Jbust one signal is generated by mouse movement & all the threads will be executed with the help of a library function. Please refer the image for the output.(task3b.png)
